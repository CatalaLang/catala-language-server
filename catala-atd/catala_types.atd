(* Type info *)

type typ = [
  | TBool
  | TInt
  | TRat
  | TMoney
  | TDate
  | TDuration
  | TUnit
  | TTuple of typ list
  | TStruct of struct_declaration
  | TEnum of enum_declaration
  | TOption of typ
  | TArray of typ
  | TArrow of (typ list * typ)
] <ocaml repr="classic">

type enum_declaration = {
  enum_name: string;
  constructors: (string * typ option) list <json repr="object"> <ts repr="map">;
}

type struct_declaration = {
  struct_name: string;
  fields: (string * typ) list <json repr="object"> <ts repr="map">;
}

type scope_def = {
  name: string;
  module_name: string;
  inputs: (string * typ) list <json repr="object"> <ts repr="map">;
  outputs: (string * typ) list <json repr="object"> <ts repr="map">;
  module_deps : string list;
}

(* Runtime values *)

type source_position = {
  filename : string;
  start_line : int;
  start_column : int;
  end_line : int;
  end_column : int;
  ~law_headings : string list;
}

type date = {
  year : int;
  month : int;
  day : int;
}

type duration = {
  years : int;
  months : int;
  days : int;
}

type runtime_value_raw = [
  | Bool of bool
  | Money of int (* Counted in cents *)
  | Integer of int
  | Decimal of float
  | Date of date
  | Duration of duration
  | Enum of (enum_declaration * (string * runtime_value option))
  | Struct of (struct_declaration * (string * runtime_value) list <json repr="object"> <ts repr="map">)
  | Array of runtime_value list <ocaml repr="array">
  | Unset (* GUI placeholder for 'impossible' value *)
  | Empty (* for diffs *)
] <ocaml repr="classic">

(* to be extended with free-form descriptions, etc. *)
type attr_def = [
  | TestDescription of string
  | TestTitle of string
  | Uid of string
  ] <ocaml repr="classic">

type runtime_value = {
  value: runtime_value_raw;
  attrs: attr_def list; (* for UIDs, comments... may be empty *)
}

(* Test data *)

type value_def = {
  value: runtime_value;
  ?pos: source_position option;
}

type test_io = {
  typ: typ;
  ?value: value_def option;
}

type test_inputs = (string * test_io) list <json repr="object"> <ts repr="map">
type test_outputs = (string * test_io) list <json repr="object"> <ts repr="map">

type test = {
  testing_scope: string;
  tested_scope: scope_def;
  test_inputs: test_inputs;
  test_outputs: test_outputs;
  description: string;
  title: string;
}

type test_run = {
  test: test;
  assert_failures: bool;
  diffs: diff list;
}

type test_list = test list

type scope_def_list = scope_def list

(* Diffing *)
type path_segment = [
  | StructField of string
  | ListIndex of int
  | TupleIndex of int
  | EnumPayload of string
]

type diff = {
  path: path_segment list;
  expected: runtime_value;
  actual: runtime_value;
}

(* Message exchange within extension (shell <-> webview) *)

type parse_results = [
  | ParseError of string (* compiler signals a parsing error *)
  | EmptyTestListMismatch (* buffer is non-empty, but empty test list returned *)
  | Results of test_list (* may be empty, that's fine as long as the buffer is empty too *)
]

type test_run_output = { (* do we need that type at all when the difference with `test_run` is minimal? *)
  test_outputs: test_outputs;
  assert_failures: bool;
  diffs: diff list;
}

type test_run_results = [
  | Error of string (* System error while attempting to run the test *)
  | Ok of test_run_output (* Ok means 'the test was run' -- there could be assertion failures *)
  | Cancelled
]

type test_generate_results = [
  | Error of string
  | Results of test_list
]

type test_run_request = {
  scope: string;
  reset_outputs: bool;
  in_shell: bool;
  debug: bool;
}

type test_generate_request = {
  scope_under_test: string;
  filename: string;
}

type test_run_results_msg = {
  scope: string;
  reset_outputs: bool;
  results: test_run_results;
}

(* Confirmation dialog IPC *)
type confirm_action = [
  | DeleteArrayElement
  | DeleteAssertion
  | RunTestWithUnsetValues
]

type confirm_request = {
  id: int;
  action: confirm_action;
}

type confirm_result = {
  id: int;
  confirmed: bool;
}

type up_message = [
  | Ready
  | GuiEdit of (test_list * bool) (* bool: 'edit may be batched' *)
  | OpenInTextEditor
  | TestRunRequest of test_run_request
  | TestGenerateRequest of test_generate_request
  | OpenTestScopePicker
  | ConfirmRequest of confirm_request
]

type down_message = [
  | Update of parse_results
  | TestRunResults of test_run_results_msg
  | ConfirmResult of confirm_result
]

(* List entrypoints *)

type gui_entrypoint = {
   scope : string;
   ?title: string option;
   ?description : string option;
}

type fonc_test_entrypoint = {
   scope : string;
}

type test_entrypoint = [
  | GUI of gui_entrypoint
  | Test of fonc_test_entrypoint
]

type no_input_scope_entrypoint = {
  scope: string;
  ?output_vars: (string * typ) list <json repr="object"> <ts repr="map"> option;
}

type input_scope_entrypoint = {
  scope: string;
  ?input_vars: (string * (typ * bool)) list <json repr="object"> <ts repr="map"> option;
  ?output_vars: (string * typ) list <json repr="object"> <ts repr="map"> option;
}

type entrypoint_kind = [
  | Test of test_entrypoint
  | NoInputScope of no_input_scope_entrypoint
  | InputScope of input_scope_entrypoint
]

type vscode_position = {
  line: int;
  character: int;
}

type vscode_range = {
  start : vscode_position;
  end_ <json name="end"> : vscode_position;
}

type entrypoint = {
  path: string;
  range: vscode_range;
  entrypoint: entrypoint_kind
}

type entrypoints = entrypoint list

type entrypoint_param_kind = [
  | GUI
  | Test
  | NoInputScope
  | InputScope
]

type entrypoints_params = {
  ?only : entrypoint_param_kind list option ;
  ?path : string option ;
  ?no_lambdas : bool option ;
  ?no_variables : bool option ;
}

type json_input = abstract