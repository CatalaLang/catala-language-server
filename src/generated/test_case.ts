/*
  Generated by atdts from type definitions in 'test_case.atd'.

  Type-safe translations from/to JSON

  For each type 'Foo', there is a pair of functions:
  - 'writeFoo': convert a 'Foo' value into a JSON-compatible value.
  - 'readFoo': convert a JSON-compatible value into a TypeScript value
    of type 'Foo'.
*/

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* tslint:disable */
/* eslint-disable */

export type Typ =
| { kind: 'TBool' }
| { kind: 'TInt' }
| { kind: 'TRat' }
| { kind: 'TMoney' }
| { kind: 'TDate' }
| { kind: 'TDuration' }
| { kind: 'TTuple'; value: Typ[] }
| { kind: 'TStruct'; value: StructDeclaration }
| { kind: 'TEnum'; value: EnumDeclaration }
| { kind: 'TOption'; value: Typ }
| { kind: 'TArray'; value: Typ }

export type EnumDeclaration = {
  enum_name: string;
  constructors: Map<string, Option<Typ>>;
}

export type StructDeclaration = {
  struct_name: string;
  fields: Map<string, Typ>;
}

export type ScopeDef = {
  name: string;
  module_name: string;
  inputs: Map<string, Typ>;
  outputs: Map<string, Typ>;
  module_deps: string[];
}

export type SourcePosition = {
  filename: string;
  start_line: number /*int*/;
  start_column: number /*int*/;
  end_line: number /*int*/;
  end_column: number /*int*/;
  law_headings: string[];
}

export type Date = {
  year: number /*int*/;
  month: number /*int*/;
  day: number /*int*/;
}

export type Duration = {
  years: number /*int*/;
  months: number /*int*/;
  days: number /*int*/;
}

export type RuntimeValueRaw =
| { kind: 'Bool'; value: boolean }
| { kind: 'Money'; value: number /*int*/ }
| { kind: 'Integer'; value: number /*int*/ }
| { kind: 'Decimal'; value: number }
| { kind: 'Date'; value: Date }
| { kind: 'Duration'; value: Duration }
| { kind: 'Enum'; value: [EnumDeclaration, [string, Option<RuntimeValue>]] }
| { kind: 'Struct'; value: [StructDeclaration, Map<string, RuntimeValue>] }
| { kind: 'Array'; value: RuntimeValue[] }
| { kind: 'Empty' }

export type AttrDef =
| { kind: 'TestDescription'; value: string }
| { kind: 'TestTitle'; value: string }
| { kind: 'Uid'; value: string }

export type RuntimeValue = {
  value: RuntimeValueRaw;
  attrs: AttrDef[];
}

export type ValueDef = {
  value: RuntimeValue;
  pos?: SourcePosition;
}

export type TestIo = {
  typ: Typ;
  value?: ValueDef;
}

export type TestInputs = Map<string, TestIo>

export type TestOutputs = Map<string, TestIo>

export type Test = {
  testing_scope: string;
  tested_scope: ScopeDef;
  test_inputs: TestInputs;
  test_outputs: TestOutputs;
  description: string;
  title: string;
}

export type TestRun = {
  test: Test;
  assert_failures: boolean;
  diffs: Diff[];
}

export type TestList = Test[]

export type ScopeDefList = ScopeDef[]

export type PathSegment =
| { kind: 'StructField'; value: string }
| { kind: 'ListIndex'; value: number /*int*/ }
| { kind: 'TupleIndex'; value: number /*int*/ }
| { kind: 'EnumPayload'; value: string }

export type Diff = {
  path: PathSegment[];
  expected: RuntimeValue;
  actual: RuntimeValue;
}

export type ParseResults =
| { kind: 'ParseError'; value: string }
| { kind: 'EmptyTestListMismatch' }
| { kind: 'Results'; value: TestList }

export type TestRunOutput = {
  test_outputs: TestOutputs;
  assert_failures: boolean;
  diffs: Diff[];
}

export type TestRunResults =
| { kind: 'Error'; value: string }
| { kind: 'Ok'; value: TestRunOutput }
| { kind: 'Cancelled' }

export type TestGenerateResults =
| { kind: 'Error'; value: string }
| { kind: 'Results'; value: TestList }

export type TestRunRequest = {
  scope: string;
  reset_outputs: boolean;
}

export type TestGenerateRequest = {
  scope_under_test: string;
  filename: string;
}

export type TestRunResultsMsg = {
  scope: string;
  reset_outputs: boolean;
  results: TestRunResults;
}

export type ConfirmAction =
| { kind: 'DeleteArrayElement' }
| { kind: 'DeleteAssertion' }

export type ConfirmRequest = {
  id: number /*int*/;
  action: ConfirmAction;
}

export type ConfirmResult = {
  id: number /*int*/;
  confirmed: boolean;
}

export type UpMessage =
| { kind: 'Ready' }
| { kind: 'GuiEdit'; value: [TestList, boolean] }
| { kind: 'OpenInTextEditor' }
| { kind: 'TestRunRequest'; value: TestRunRequest }
| { kind: 'TestGenerateRequest'; value: TestGenerateRequest }
| { kind: 'OpenTestScopePicker' }
| { kind: 'ConfirmRequest'; value: ConfirmRequest }

export type DownMessage =
| { kind: 'Update'; value: ParseResults }
| { kind: 'TestRunResults'; value: TestRunResultsMsg }
| { kind: 'ConfirmResult'; value: ConfirmResult }

export function writeTyp(x: Typ, context: any = x): any {
  switch (x.kind) {
    case 'TBool':
      return 'TBool'
    case 'TInt':
      return 'TInt'
    case 'TRat':
      return 'TRat'
    case 'TMoney':
      return 'TMoney'
    case 'TDate':
      return 'TDate'
    case 'TDuration':
      return 'TDuration'
    case 'TTuple':
      return ['TTuple', _atd_write_array(writeTyp)(x.value, x)]
    case 'TStruct':
      return ['TStruct', writeStructDeclaration(x.value, x)]
    case 'TEnum':
      return ['TEnum', writeEnumDeclaration(x.value, x)]
    case 'TOption':
      return ['TOption', writeTyp(x.value, x)]
    case 'TArray':
      return ['TArray', writeTyp(x.value, x)]
  }
}

export function readTyp(x: any, context: any = x): Typ {
  if (typeof x === 'string') {
    switch (x) {
      case 'TBool':
        return { kind: 'TBool' }
      case 'TInt':
        return { kind: 'TInt' }
      case 'TRat':
        return { kind: 'TRat' }
      case 'TMoney':
        return { kind: 'TMoney' }
      case 'TDate':
        return { kind: 'TDate' }
      case 'TDuration':
        return { kind: 'TDuration' }
      default:
        _atd_bad_json('Typ', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'TTuple':
        return { kind: 'TTuple', value: _atd_read_array(readTyp)(x[1], x) }
      case 'TStruct':
        return { kind: 'TStruct', value: readStructDeclaration(x[1], x) }
      case 'TEnum':
        return { kind: 'TEnum', value: readEnumDeclaration(x[1], x) }
      case 'TOption':
        return { kind: 'TOption', value: readTyp(x[1], x) }
      case 'TArray':
        return { kind: 'TArray', value: readTyp(x[1], x) }
      default:
        _atd_bad_json('Typ', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeEnumDeclaration(x: EnumDeclaration, context: any = x): any {
  return {
    'enum_name': _atd_write_required_field('EnumDeclaration', 'enum_name', _atd_write_string, x.enum_name, x),
    'constructors': _atd_write_required_field('EnumDeclaration', 'constructors', _atd_write_assoc_map_to_object(_atd_write_option(writeTyp)), x.constructors, x),
  };
}

export function readEnumDeclaration(x: any, context: any = x): EnumDeclaration {
  return {
    enum_name: _atd_read_required_field('EnumDeclaration', 'enum_name', _atd_read_string, x['enum_name'], x),
    constructors: _atd_read_required_field('EnumDeclaration', 'constructors', _atd_read_assoc_object_into_map(_atd_read_option(readTyp)), x['constructors'], x),
  };
}

export function writeStructDeclaration(x: StructDeclaration, context: any = x): any {
  return {
    'struct_name': _atd_write_required_field('StructDeclaration', 'struct_name', _atd_write_string, x.struct_name, x),
    'fields': _atd_write_required_field('StructDeclaration', 'fields', _atd_write_assoc_map_to_object(writeTyp), x.fields, x),
  };
}

export function readStructDeclaration(x: any, context: any = x): StructDeclaration {
  return {
    struct_name: _atd_read_required_field('StructDeclaration', 'struct_name', _atd_read_string, x['struct_name'], x),
    fields: _atd_read_required_field('StructDeclaration', 'fields', _atd_read_assoc_object_into_map(readTyp), x['fields'], x),
  };
}

export function writeScopeDef(x: ScopeDef, context: any = x): any {
  return {
    'name': _atd_write_required_field('ScopeDef', 'name', _atd_write_string, x.name, x),
    'module_name': _atd_write_required_field('ScopeDef', 'module_name', _atd_write_string, x.module_name, x),
    'inputs': _atd_write_required_field('ScopeDef', 'inputs', _atd_write_assoc_map_to_object(writeTyp), x.inputs, x),
    'outputs': _atd_write_required_field('ScopeDef', 'outputs', _atd_write_assoc_map_to_object(writeTyp), x.outputs, x),
    'module_deps': _atd_write_required_field('ScopeDef', 'module_deps', _atd_write_array(_atd_write_string), x.module_deps, x),
  };
}

export function readScopeDef(x: any, context: any = x): ScopeDef {
  return {
    name: _atd_read_required_field('ScopeDef', 'name', _atd_read_string, x['name'], x),
    module_name: _atd_read_required_field('ScopeDef', 'module_name', _atd_read_string, x['module_name'], x),
    inputs: _atd_read_required_field('ScopeDef', 'inputs', _atd_read_assoc_object_into_map(readTyp), x['inputs'], x),
    outputs: _atd_read_required_field('ScopeDef', 'outputs', _atd_read_assoc_object_into_map(readTyp), x['outputs'], x),
    module_deps: _atd_read_required_field('ScopeDef', 'module_deps', _atd_read_array(_atd_read_string), x['module_deps'], x),
  };
}

export function writeSourcePosition(x: SourcePosition, context: any = x): any {
  return {
    'filename': _atd_write_required_field('SourcePosition', 'filename', _atd_write_string, x.filename, x),
    'start_line': _atd_write_required_field('SourcePosition', 'start_line', _atd_write_int, x.start_line, x),
    'start_column': _atd_write_required_field('SourcePosition', 'start_column', _atd_write_int, x.start_column, x),
    'end_line': _atd_write_required_field('SourcePosition', 'end_line', _atd_write_int, x.end_line, x),
    'end_column': _atd_write_required_field('SourcePosition', 'end_column', _atd_write_int, x.end_column, x),
    'law_headings': _atd_write_field_with_default(_atd_write_array(_atd_write_string), [], x.law_headings, x),
  };
}

export function readSourcePosition(x: any, context: any = x): SourcePosition {
  return {
    filename: _atd_read_required_field('SourcePosition', 'filename', _atd_read_string, x['filename'], x),
    start_line: _atd_read_required_field('SourcePosition', 'start_line', _atd_read_int, x['start_line'], x),
    start_column: _atd_read_required_field('SourcePosition', 'start_column', _atd_read_int, x['start_column'], x),
    end_line: _atd_read_required_field('SourcePosition', 'end_line', _atd_read_int, x['end_line'], x),
    end_column: _atd_read_required_field('SourcePosition', 'end_column', _atd_read_int, x['end_column'], x),
    law_headings: _atd_read_field_with_default(_atd_read_array(_atd_read_string), [], x['law_headings'], x),
  };
}

export function writeDate(x: Date, context: any = x): any {
  return {
    'year': _atd_write_required_field('Date', 'year', _atd_write_int, x.year, x),
    'month': _atd_write_required_field('Date', 'month', _atd_write_int, x.month, x),
    'day': _atd_write_required_field('Date', 'day', _atd_write_int, x.day, x),
  };
}

export function readDate(x: any, context: any = x): Date {
  return {
    year: _atd_read_required_field('Date', 'year', _atd_read_int, x['year'], x),
    month: _atd_read_required_field('Date', 'month', _atd_read_int, x['month'], x),
    day: _atd_read_required_field('Date', 'day', _atd_read_int, x['day'], x),
  };
}

export function writeDuration(x: Duration, context: any = x): any {
  return {
    'years': _atd_write_required_field('Duration', 'years', _atd_write_int, x.years, x),
    'months': _atd_write_required_field('Duration', 'months', _atd_write_int, x.months, x),
    'days': _atd_write_required_field('Duration', 'days', _atd_write_int, x.days, x),
  };
}

export function readDuration(x: any, context: any = x): Duration {
  return {
    years: _atd_read_required_field('Duration', 'years', _atd_read_int, x['years'], x),
    months: _atd_read_required_field('Duration', 'months', _atd_read_int, x['months'], x),
    days: _atd_read_required_field('Duration', 'days', _atd_read_int, x['days'], x),
  };
}

export function writeRuntimeValueRaw(x: RuntimeValueRaw, context: any = x): any {
  switch (x.kind) {
    case 'Bool':
      return ['Bool', _atd_write_bool(x.value, x)]
    case 'Money':
      return ['Money', _atd_write_int(x.value, x)]
    case 'Integer':
      return ['Integer', _atd_write_int(x.value, x)]
    case 'Decimal':
      return ['Decimal', _atd_write_float(x.value, x)]
    case 'Date':
      return ['Date', writeDate(x.value, x)]
    case 'Duration':
      return ['Duration', writeDuration(x.value, x)]
    case 'Enum':
      return ['Enum', ((x, context) => [writeEnumDeclaration(x[0], x), ((x, context) => [_atd_write_string(x[0], x), _atd_write_option(writeRuntimeValue)(x[1], x)])(x[1], x)])(x.value, x)]
    case 'Struct':
      return ['Struct', ((x, context) => [writeStructDeclaration(x[0], x), _atd_write_assoc_map_to_object(writeRuntimeValue)(x[1], x)])(x.value, x)]
    case 'Array':
      return ['Array', _atd_write_array(writeRuntimeValue)(x.value, x)]
    case 'Empty':
      return 'Empty'
  }
}

export function readRuntimeValueRaw(x: any, context: any = x): RuntimeValueRaw {
  if (typeof x === 'string') {
    switch (x) {
      case 'Empty':
        return { kind: 'Empty' }
      default:
        _atd_bad_json('RuntimeValueRaw', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'Bool':
        return { kind: 'Bool', value: _atd_read_bool(x[1], x) }
      case 'Money':
        return { kind: 'Money', value: _atd_read_int(x[1], x) }
      case 'Integer':
        return { kind: 'Integer', value: _atd_read_int(x[1], x) }
      case 'Decimal':
        return { kind: 'Decimal', value: _atd_read_float(x[1], x) }
      case 'Date':
        return { kind: 'Date', value: readDate(x[1], x) }
      case 'Duration':
        return { kind: 'Duration', value: readDuration(x[1], x) }
      case 'Enum':
        return { kind: 'Enum', value: ((x, context): [EnumDeclaration, [string, Option<RuntimeValue>]] => { _atd_check_json_tuple(2, x, context); return [readEnumDeclaration(x[0], x), ((x, context): [string, Option<RuntimeValue>] => { _atd_check_json_tuple(2, x, context); return [_atd_read_string(x[0], x), _atd_read_option(readRuntimeValue)(x[1], x)] })(x[1], x)] })(x[1], x) }
      case 'Struct':
        return { kind: 'Struct', value: ((x, context): [StructDeclaration, Map<string, RuntimeValue>] => { _atd_check_json_tuple(2, x, context); return [readStructDeclaration(x[0], x), _atd_read_assoc_object_into_map(readRuntimeValue)(x[1], x)] })(x[1], x) }
      case 'Array':
        return { kind: 'Array', value: _atd_read_array(readRuntimeValue)(x[1], x) }
      default:
        _atd_bad_json('RuntimeValueRaw', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeAttrDef(x: AttrDef, context: any = x): any {
  switch (x.kind) {
    case 'TestDescription':
      return ['TestDescription', _atd_write_string(x.value, x)]
    case 'TestTitle':
      return ['TestTitle', _atd_write_string(x.value, x)]
    case 'Uid':
      return ['Uid', _atd_write_string(x.value, x)]
  }
}

export function readAttrDef(x: any, context: any = x): AttrDef {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'TestDescription':
      return { kind: 'TestDescription', value: _atd_read_string(x[1], x) }
    case 'TestTitle':
      return { kind: 'TestTitle', value: _atd_read_string(x[1], x) }
    case 'Uid':
      return { kind: 'Uid', value: _atd_read_string(x[1], x) }
    default:
      _atd_bad_json('AttrDef', x, context)
      throw new Error('impossible')
  }
}

export function writeRuntimeValue(x: RuntimeValue, context: any = x): any {
  return {
    'value': _atd_write_required_field('RuntimeValue', 'value', writeRuntimeValueRaw, x.value, x),
    'attrs': _atd_write_required_field('RuntimeValue', 'attrs', _atd_write_array(writeAttrDef), x.attrs, x),
  };
}

export function readRuntimeValue(x: any, context: any = x): RuntimeValue {
  return {
    value: _atd_read_required_field('RuntimeValue', 'value', readRuntimeValueRaw, x['value'], x),
    attrs: _atd_read_required_field('RuntimeValue', 'attrs', _atd_read_array(readAttrDef), x['attrs'], x),
  };
}

export function writeValueDef(x: ValueDef, context: any = x): any {
  return {
    'value': _atd_write_required_field('ValueDef', 'value', writeRuntimeValue, x.value, x),
    'pos': _atd_write_optional_field(writeSourcePosition, x.pos, x),
  };
}

export function readValueDef(x: any, context: any = x): ValueDef {
  return {
    value: _atd_read_required_field('ValueDef', 'value', readRuntimeValue, x['value'], x),
    pos: _atd_read_optional_field(readSourcePosition, x['pos'], x),
  };
}

export function writeTestIo(x: TestIo, context: any = x): any {
  return {
    'typ': _atd_write_required_field('TestIo', 'typ', writeTyp, x.typ, x),
    'value': _atd_write_optional_field(writeValueDef, x.value, x),
  };
}

export function readTestIo(x: any, context: any = x): TestIo {
  return {
    typ: _atd_read_required_field('TestIo', 'typ', readTyp, x['typ'], x),
    value: _atd_read_optional_field(readValueDef, x['value'], x),
  };
}

export function writeTestInputs(x: TestInputs, context: any = x): any {
  return _atd_write_assoc_map_to_object(writeTestIo)(x, context);
}

export function readTestInputs(x: any, context: any = x): TestInputs {
  return _atd_read_assoc_object_into_map(readTestIo)(x, context);
}

export function writeTestOutputs(x: TestOutputs, context: any = x): any {
  return _atd_write_assoc_map_to_object(writeTestIo)(x, context);
}

export function readTestOutputs(x: any, context: any = x): TestOutputs {
  return _atd_read_assoc_object_into_map(readTestIo)(x, context);
}

export function writeTest(x: Test, context: any = x): any {
  return {
    'testing_scope': _atd_write_required_field('Test', 'testing_scope', _atd_write_string, x.testing_scope, x),
    'tested_scope': _atd_write_required_field('Test', 'tested_scope', writeScopeDef, x.tested_scope, x),
    'test_inputs': _atd_write_required_field('Test', 'test_inputs', writeTestInputs, x.test_inputs, x),
    'test_outputs': _atd_write_required_field('Test', 'test_outputs', writeTestOutputs, x.test_outputs, x),
    'description': _atd_write_required_field('Test', 'description', _atd_write_string, x.description, x),
    'title': _atd_write_required_field('Test', 'title', _atd_write_string, x.title, x),
  };
}

export function readTest(x: any, context: any = x): Test {
  return {
    testing_scope: _atd_read_required_field('Test', 'testing_scope', _atd_read_string, x['testing_scope'], x),
    tested_scope: _atd_read_required_field('Test', 'tested_scope', readScopeDef, x['tested_scope'], x),
    test_inputs: _atd_read_required_field('Test', 'test_inputs', readTestInputs, x['test_inputs'], x),
    test_outputs: _atd_read_required_field('Test', 'test_outputs', readTestOutputs, x['test_outputs'], x),
    description: _atd_read_required_field('Test', 'description', _atd_read_string, x['description'], x),
    title: _atd_read_required_field('Test', 'title', _atd_read_string, x['title'], x),
  };
}

export function writeTestRun(x: TestRun, context: any = x): any {
  return {
    'test': _atd_write_required_field('TestRun', 'test', writeTest, x.test, x),
    'assert_failures': _atd_write_required_field('TestRun', 'assert_failures', _atd_write_bool, x.assert_failures, x),
    'diffs': _atd_write_required_field('TestRun', 'diffs', _atd_write_array(writeDiff), x.diffs, x),
  };
}

export function readTestRun(x: any, context: any = x): TestRun {
  return {
    test: _atd_read_required_field('TestRun', 'test', readTest, x['test'], x),
    assert_failures: _atd_read_required_field('TestRun', 'assert_failures', _atd_read_bool, x['assert_failures'], x),
    diffs: _atd_read_required_field('TestRun', 'diffs', _atd_read_array(readDiff), x['diffs'], x),
  };
}

export function writeTestList(x: TestList, context: any = x): any {
  return _atd_write_array(writeTest)(x, context);
}

export function readTestList(x: any, context: any = x): TestList {
  return _atd_read_array(readTest)(x, context);
}

export function writeScopeDefList(x: ScopeDefList, context: any = x): any {
  return _atd_write_array(writeScopeDef)(x, context);
}

export function readScopeDefList(x: any, context: any = x): ScopeDefList {
  return _atd_read_array(readScopeDef)(x, context);
}

export function writePathSegment(x: PathSegment, context: any = x): any {
  switch (x.kind) {
    case 'StructField':
      return ['StructField', _atd_write_string(x.value, x)]
    case 'ListIndex':
      return ['ListIndex', _atd_write_int(x.value, x)]
    case 'TupleIndex':
      return ['TupleIndex', _atd_write_int(x.value, x)]
    case 'EnumPayload':
      return ['EnumPayload', _atd_write_string(x.value, x)]
  }
}

export function readPathSegment(x: any, context: any = x): PathSegment {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'StructField':
      return { kind: 'StructField', value: _atd_read_string(x[1], x) }
    case 'ListIndex':
      return { kind: 'ListIndex', value: _atd_read_int(x[1], x) }
    case 'TupleIndex':
      return { kind: 'TupleIndex', value: _atd_read_int(x[1], x) }
    case 'EnumPayload':
      return { kind: 'EnumPayload', value: _atd_read_string(x[1], x) }
    default:
      _atd_bad_json('PathSegment', x, context)
      throw new Error('impossible')
  }
}

export function writeDiff(x: Diff, context: any = x): any {
  return {
    'path': _atd_write_required_field('Diff', 'path', _atd_write_array(writePathSegment), x.path, x),
    'expected': _atd_write_required_field('Diff', 'expected', writeRuntimeValue, x.expected, x),
    'actual': _atd_write_required_field('Diff', 'actual', writeRuntimeValue, x.actual, x),
  };
}

export function readDiff(x: any, context: any = x): Diff {
  return {
    path: _atd_read_required_field('Diff', 'path', _atd_read_array(readPathSegment), x['path'], x),
    expected: _atd_read_required_field('Diff', 'expected', readRuntimeValue, x['expected'], x),
    actual: _atd_read_required_field('Diff', 'actual', readRuntimeValue, x['actual'], x),
  };
}

export function writeParseResults(x: ParseResults, context: any = x): any {
  switch (x.kind) {
    case 'ParseError':
      return ['ParseError', _atd_write_string(x.value, x)]
    case 'EmptyTestListMismatch':
      return 'EmptyTestListMismatch'
    case 'Results':
      return ['Results', writeTestList(x.value, x)]
  }
}

export function readParseResults(x: any, context: any = x): ParseResults {
  if (typeof x === 'string') {
    switch (x) {
      case 'EmptyTestListMismatch':
        return { kind: 'EmptyTestListMismatch' }
      default:
        _atd_bad_json('ParseResults', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'ParseError':
        return { kind: 'ParseError', value: _atd_read_string(x[1], x) }
      case 'Results':
        return { kind: 'Results', value: readTestList(x[1], x) }
      default:
        _atd_bad_json('ParseResults', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeTestRunOutput(x: TestRunOutput, context: any = x): any {
  return {
    'test_outputs': _atd_write_required_field('TestRunOutput', 'test_outputs', writeTestOutputs, x.test_outputs, x),
    'assert_failures': _atd_write_required_field('TestRunOutput', 'assert_failures', _atd_write_bool, x.assert_failures, x),
    'diffs': _atd_write_required_field('TestRunOutput', 'diffs', _atd_write_array(writeDiff), x.diffs, x),
  };
}

export function readTestRunOutput(x: any, context: any = x): TestRunOutput {
  return {
    test_outputs: _atd_read_required_field('TestRunOutput', 'test_outputs', readTestOutputs, x['test_outputs'], x),
    assert_failures: _atd_read_required_field('TestRunOutput', 'assert_failures', _atd_read_bool, x['assert_failures'], x),
    diffs: _atd_read_required_field('TestRunOutput', 'diffs', _atd_read_array(readDiff), x['diffs'], x),
  };
}

export function writeTestRunResults(x: TestRunResults, context: any = x): any {
  switch (x.kind) {
    case 'Error':
      return ['Error', _atd_write_string(x.value, x)]
    case 'Ok':
      return ['Ok', writeTestRunOutput(x.value, x)]
    case 'Cancelled':
      return 'Cancelled'
  }
}

export function readTestRunResults(x: any, context: any = x): TestRunResults {
  if (typeof x === 'string') {
    switch (x) {
      case 'Cancelled':
        return { kind: 'Cancelled' }
      default:
        _atd_bad_json('TestRunResults', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'Error':
        return { kind: 'Error', value: _atd_read_string(x[1], x) }
      case 'Ok':
        return { kind: 'Ok', value: readTestRunOutput(x[1], x) }
      default:
        _atd_bad_json('TestRunResults', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeTestGenerateResults(x: TestGenerateResults, context: any = x): any {
  switch (x.kind) {
    case 'Error':
      return ['Error', _atd_write_string(x.value, x)]
    case 'Results':
      return ['Results', writeTestList(x.value, x)]
  }
}

export function readTestGenerateResults(x: any, context: any = x): TestGenerateResults {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'Error':
      return { kind: 'Error', value: _atd_read_string(x[1], x) }
    case 'Results':
      return { kind: 'Results', value: readTestList(x[1], x) }
    default:
      _atd_bad_json('TestGenerateResults', x, context)
      throw new Error('impossible')
  }
}

export function writeTestRunRequest(x: TestRunRequest, context: any = x): any {
  return {
    'scope': _atd_write_required_field('TestRunRequest', 'scope', _atd_write_string, x.scope, x),
    'reset_outputs': _atd_write_required_field('TestRunRequest', 'reset_outputs', _atd_write_bool, x.reset_outputs, x),
  };
}

export function readTestRunRequest(x: any, context: any = x): TestRunRequest {
  return {
    scope: _atd_read_required_field('TestRunRequest', 'scope', _atd_read_string, x['scope'], x),
    reset_outputs: _atd_read_required_field('TestRunRequest', 'reset_outputs', _atd_read_bool, x['reset_outputs'], x),
  };
}

export function writeTestGenerateRequest(x: TestGenerateRequest, context: any = x): any {
  return {
    'scope_under_test': _atd_write_required_field('TestGenerateRequest', 'scope_under_test', _atd_write_string, x.scope_under_test, x),
    'filename': _atd_write_required_field('TestGenerateRequest', 'filename', _atd_write_string, x.filename, x),
  };
}

export function readTestGenerateRequest(x: any, context: any = x): TestGenerateRequest {
  return {
    scope_under_test: _atd_read_required_field('TestGenerateRequest', 'scope_under_test', _atd_read_string, x['scope_under_test'], x),
    filename: _atd_read_required_field('TestGenerateRequest', 'filename', _atd_read_string, x['filename'], x),
  };
}

export function writeTestRunResultsMsg(x: TestRunResultsMsg, context: any = x): any {
  return {
    'scope': _atd_write_required_field('TestRunResultsMsg', 'scope', _atd_write_string, x.scope, x),
    'reset_outputs': _atd_write_required_field('TestRunResultsMsg', 'reset_outputs', _atd_write_bool, x.reset_outputs, x),
    'results': _atd_write_required_field('TestRunResultsMsg', 'results', writeTestRunResults, x.results, x),
  };
}

export function readTestRunResultsMsg(x: any, context: any = x): TestRunResultsMsg {
  return {
    scope: _atd_read_required_field('TestRunResultsMsg', 'scope', _atd_read_string, x['scope'], x),
    reset_outputs: _atd_read_required_field('TestRunResultsMsg', 'reset_outputs', _atd_read_bool, x['reset_outputs'], x),
    results: _atd_read_required_field('TestRunResultsMsg', 'results', readTestRunResults, x['results'], x),
  };
}

export function writeConfirmAction(x: ConfirmAction, context: any = x): any {
  switch (x.kind) {
    case 'DeleteArrayElement':
      return 'DeleteArrayElement'
    case 'DeleteAssertion':
      return 'DeleteAssertion'
  }
}

export function readConfirmAction(x: any, context: any = x): ConfirmAction {
  switch (x) {
    case 'DeleteArrayElement':
      return { kind: 'DeleteArrayElement' }
    case 'DeleteAssertion':
      return { kind: 'DeleteAssertion' }
    default:
      _atd_bad_json('ConfirmAction', x, context)
      throw new Error('impossible')
  }
}

export function writeConfirmRequest(x: ConfirmRequest, context: any = x): any {
  return {
    'id': _atd_write_required_field('ConfirmRequest', 'id', _atd_write_int, x.id, x),
    'action': _atd_write_required_field('ConfirmRequest', 'action', writeConfirmAction, x.action, x),
  };
}

export function readConfirmRequest(x: any, context: any = x): ConfirmRequest {
  return {
    id: _atd_read_required_field('ConfirmRequest', 'id', _atd_read_int, x['id'], x),
    action: _atd_read_required_field('ConfirmRequest', 'action', readConfirmAction, x['action'], x),
  };
}

export function writeConfirmResult(x: ConfirmResult, context: any = x): any {
  return {
    'id': _atd_write_required_field('ConfirmResult', 'id', _atd_write_int, x.id, x),
    'confirmed': _atd_write_required_field('ConfirmResult', 'confirmed', _atd_write_bool, x.confirmed, x),
  };
}

export function readConfirmResult(x: any, context: any = x): ConfirmResult {
  return {
    id: _atd_read_required_field('ConfirmResult', 'id', _atd_read_int, x['id'], x),
    confirmed: _atd_read_required_field('ConfirmResult', 'confirmed', _atd_read_bool, x['confirmed'], x),
  };
}

export function writeUpMessage(x: UpMessage, context: any = x): any {
  switch (x.kind) {
    case 'Ready':
      return 'Ready'
    case 'GuiEdit':
      return ['GuiEdit', ((x, context) => [writeTestList(x[0], x), _atd_write_bool(x[1], x)])(x.value, x)]
    case 'OpenInTextEditor':
      return 'OpenInTextEditor'
    case 'TestRunRequest':
      return ['TestRunRequest', writeTestRunRequest(x.value, x)]
    case 'TestGenerateRequest':
      return ['TestGenerateRequest', writeTestGenerateRequest(x.value, x)]
    case 'OpenTestScopePicker':
      return 'OpenTestScopePicker'
    case 'ConfirmRequest':
      return ['ConfirmRequest', writeConfirmRequest(x.value, x)]
  }
}

export function readUpMessage(x: any, context: any = x): UpMessage {
  if (typeof x === 'string') {
    switch (x) {
      case 'Ready':
        return { kind: 'Ready' }
      case 'OpenInTextEditor':
        return { kind: 'OpenInTextEditor' }
      case 'OpenTestScopePicker':
        return { kind: 'OpenTestScopePicker' }
      default:
        _atd_bad_json('UpMessage', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'GuiEdit':
        return { kind: 'GuiEdit', value: ((x, context): [TestList, boolean] => { _atd_check_json_tuple(2, x, context); return [readTestList(x[0], x), _atd_read_bool(x[1], x)] })(x[1], x) }
      case 'TestRunRequest':
        return { kind: 'TestRunRequest', value: readTestRunRequest(x[1], x) }
      case 'TestGenerateRequest':
        return { kind: 'TestGenerateRequest', value: readTestGenerateRequest(x[1], x) }
      case 'ConfirmRequest':
        return { kind: 'ConfirmRequest', value: readConfirmRequest(x[1], x) }
      default:
        _atd_bad_json('UpMessage', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeDownMessage(x: DownMessage, context: any = x): any {
  switch (x.kind) {
    case 'Update':
      return ['Update', writeParseResults(x.value, x)]
    case 'TestRunResults':
      return ['TestRunResults', writeTestRunResultsMsg(x.value, x)]
    case 'ConfirmResult':
      return ['ConfirmResult', writeConfirmResult(x.value, x)]
  }
}

export function readDownMessage(x: any, context: any = x): DownMessage {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'Update':
      return { kind: 'Update', value: readParseResults(x[1], x) }
    case 'TestRunResults':
      return { kind: 'TestRunResults', value: readTestRunResultsMsg(x[1], x) }
    case 'ConfirmResult':
      return { kind: 'ConfirmResult', value: readConfirmResult(x[1], x) }
    default:
      _atd_bad_json('DownMessage', x, context)
      throw new Error('impossible')
  }
}


/////////////////////////////////////////////////////////////////////
// Runtime library
/////////////////////////////////////////////////////////////////////

export type Option<T> = null | { value: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_missing_ts_field(type_name: string, ts_field_name: string) {
    throw new Error(`missing field '${ts_field_name}'` +
                    ` in TypeScript object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any, context: any) {
  let value_str = JSON.stringify(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_bad_ts(expected_type: string, ts_value: any, context: any) {
  let value_str = JSON.stringify(ts_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_check_json_tuple(len: number /*int*/, x: any, context: any) {
  if (! Array.isArray(x) || x.length !== len)
    _atd_bad_json('tuple of length ' + len, x, context);
}

function _atd_read_unit(x: any, context: any): null {
  if (x === null)
    return null
  else {
    _atd_bad_json('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_json('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_int(x: any, context: any): number /*int*/ {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_json('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_json('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_json('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_required_field<T>(type_name: string,
                                     field_name: string,
                                     read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined) {
    _atd_missing_json_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return read_elt(x, context)
}

function _atd_read_optional_field<T>(read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined || x === null)
    return x
  else
    return read_elt(x, context)
}

function _atd_read_field_with_default<T>(read_elt: (x: any, context: any) => T,
                                         default_: T,
                                         x: any,
                                         context: any): T {
  if (x === undefined || x === null)
    return default_
  else
    return read_elt(x, context)
}

function _atd_read_option<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => Option<T> {
  function read_option(x: any, context: any): Option<T> {
    if (x === 'None')
      return null
    else {
      _atd_check_json_tuple(2, x, context);
      switch (x[0]) {
        case 'Some':
          return { value: read_elt(x[1], context) }
        default:
          _atd_bad_json('option', x, context)
          throw new Error('impossible')
      }
    }
  }
  return read_option
}

function _atd_read_nullable<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => T | null {
  function read_nullable(x: any, context: any): T | null {
    if (x === null)
      return null
    else
      return read_elt(x, context)
  }
  return read_nullable
}

function _atd_read_array<T>(read_elt: (x: any, context: any) => T):
  (elts: any, context: any) => T[] {
  function read_array(elts: any, context: any): T[] {
    if (Array.isArray(elts))
      return elts.map((x) => read_elt(x, elts))
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_array
}

function _atd_read_assoc_array_into_map<K, V>(
    read_key: (key: any, context: any) => K,
    read_value: (value: any, context: any) => V
  ): (x: any, context: any) => Map<K, V> {
  function read_assoc(elts: any, context: any): Map<K, V> {
    if (Array.isArray(elts)) {
      const res = new Map<K, V>([])
      for (const x of elts) {
        if (Array.isArray(x) && x.length === 2)
          res.set(read_key(x[0], x), read_value(x[1], x))
        else {
          _atd_bad_json('pair', x, elts)
          throw new Error('impossible')
        }
      }
      return res
    }
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_map<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => Map<string, T> {
  function read_assoc(elts: any, context: any): Map<string, T> {
    if (typeof elts === 'object') {
      const res = new Map<string, T>([])
      for (const [key, value] of Object.entries(elts))
        res.set(key, read_value(value, elts))
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_array<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => [string, T][] {
  function read_assoc(elts: any, context: any): [string, T][] {
    if (typeof elts === 'object') {
      const res: [string, T][] = []
      for (const [key, value] of Object.entries(elts))
        res.push([key, read_value(value, elts)])
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_write_unit(x: any, context: any) {
  if (x === null)
    return x
  else {
    _atd_bad_ts('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_ts('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_int(x: any, context: any): number /*int*/ {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_ts('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_ts('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_ts('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_option<T>(write_elt: (x: T, context: any) => any):
   (elts: Option<T>, context: any) => any {
  function write_option(x: Option<T>, context: any): any {
    if (x === null)
      return 'None'
    else
      return ['Some', write_elt(x.value, context)]
  }
  return write_option
}

function _atd_write_nullable<T>(write_elt: (x: T, context: any) => any):
  (x: T | null, context: any) => any {
  function write_option(x: T | null, context: any): any {
    if (x === null)
      return null
    else
      return write_elt(x, context)
  }
  return write_option
}

function _atd_write_array<T>(write_elt: (elt: T, context: any) => any):
  (elts: T[], context: any) => any {
  return ((elts: T[], context: any): any =>
    elts.map((x) => write_elt(x, elts))
  )
}

function _atd_write_assoc_map_to_array<K, V>(
    write_key: (key: K, context: any) => any,
    write_value: (value: V, context: any) => any
  ): (elts: Map<K, V>, context: any) => any {
  function write_assoc(elts: Map<K, V>, context: any): any {
    const res: any = []
    elts.forEach((value: V, key: K) =>
      res.push([write_key(key, elts), write_value(value, elts)])
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_map_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: Map<string, T>, context: any) => any {
  function write_assoc(elts: Map<string, T>, context: any): any {
    const res: any = {}
    elts.forEach((value: T, key: string) =>
      res[key] = write_value(value, elts)
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_array_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: [string, T][], context: any) => any {
  function write_assoc(elts: [string, T][], context: any): any {
    const res: any = {}
    for (const [key, value] of elts)
      res[key] = write_value(value, elts)
    return res
  }
  return write_assoc
}

function _atd_write_required_field<T>(type_name: string,
                                      field_name: string,
                                      write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined) {
    _atd_missing_ts_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return write_elt(x, context)
}

function _atd_write_optional_field<T>(write_elt: (x: T, context: any) => any,
                                      x: T | undefined,
                                      context: any): any {
  if (x === undefined || x === null)
    return x
  else
    return write_elt(x, context)
}

function _atd_write_field_with_default<T>(
  write_elt: (x: T, context: any) => any,
  default_: T,
  x: T,
  context: any
): T {
  const value = (x === undefined || x === null) ? default_ : x
  return write_elt(value, context)
}

